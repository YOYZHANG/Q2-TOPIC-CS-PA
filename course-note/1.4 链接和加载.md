# 链接器

链接器将所需的简单目标文件汇集起来形成

1. 拼图游戏当中每个拼块都依赖于其他拼块提供的拼接口
2. 保证目标文件的相互依赖关系成立，这就是符号决议。
3. 链接器还需要保证可以重定向

链接器的工作过程：

1. 进行符号决议，确保模块间的依赖是正确的
2. ~~集合打包成库或可执行文件~~
3. 链接器对链接好的库或可执行文件进行重定位

链接器需要做的工作就是确保目标文件中的符号引用都有

唯一定义。

C源文件中都有什么？

变量：

-全局变量：

-局部变量

目标文件里有什么

编译器的任务就是吧人类可以理解的代码转换成机器可以执行的机器指令，源文件编译后生成的对应的目标文件本质上只有两个部分：

代码部分： 计算机的可执行机器指令，也就是源文件中定义的所有函数。

数据部分： 源文件中定义的全局变量，如果是已经初始化后的全局变量，该全局变量也存在与数据部分。

到目前为止，你可以把一个目标文件简单的理解为两部分：

- 代码部分： 函数里面使用的局部变量没有放到目标文件的数据段中，这是因为局部变量是函数私有的，局部函数只能在该函数内部使用而全局变量时没有这个限制。
- 数据部分

编译器在遇到外部定义的全部变量或者函数时只要能在当前文件找到其声明，编译器就认为编译正确，而寻找使用变量定义的这项任务是链接器。

链接器的一项任务即使确定所使用的变量有唯一的定义。

链接器分担了一部分工作，这部分工作就是符号表。

### 符号表

符号表中保存的信息有两部分：

- 该目标文件中引用的全局变量及函数
- 该目标中定义的全局变量及函数

本质上整个符号表想表达两件事：

- 我能提供给其他文件使用的符号
- 我需要其他文件提供给我使用的符号

### 符号表存放在哪里

在目标文件里有什么这一小节，我们将一个目标文件简单的花粉了两段：

- 数据段
- 代码段
- 符号表（在他们俩后面

### 符号决议的过程

假设链接器需要链接三个目标文件：

链接器会一次扫描每个给定的目标文件，同时链接器还维护两个集合，一个是一个是已定义符号集合D，另一个是未定义符合集合U，下面是链接器进行符合决议的过程：

，对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合D中。

2，对于当前目标文件，查找其符号表，将每一个当前目标文件引用的符号与已定义符号集合D进行对比，如果该符号不在集合D中则将其添加到未定义符合集合U中。

3，当所有文件都扫描完成后，如果为定义符号集合U不为空，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止。

## 库与可执行文件的生成

给定目标文件以及链接选项，链接器可以生成两种库，分别是静态库以及动态库。如图所示，给定同样的目标文件，链接器可以生成两种不同类型的库：

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16796636-97a0-4e68-9a11-e21245dc481d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16796636-97a0-4e68-9a11-e21245dc481d/Untitled.png)

### 静态库

静态库在windows下是以.lib为后缀的文件，linux下是以.a为后缀的文件。

可以简单的将静态库理解成由一堆目标文件打包而成，使用者只需要使用其中的函数而无需关注函数来自哪个目标文件。

### 静态链接

静态库是链接器通过静态链接将其和其他目标文件合并生成可执行文件的。

### 静态链接下可执行文件的生成

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b19dcff0-854a-4f02-96b5-ee970d943486/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b19dcff0-854a-4f02-96b5-ee970d943486/Untitled.png)

可执行文件的额特点：

- 可执行文件和目标文件一样，也是由代码段和数据段组成
- 每个目标文件中的数据段都合并到了可执行文件的数据段
- 目标文件的符号表没有合并到可执行文件中

可执行文件区别与目标文件的地方在于，可执行文件有一个入口函数，main函数在执行过程中会遇到所有可执行文件当中的代码和数据。这个main函数是操作系统来执行。

## 动态库

静态链接会将用到的目标文件直接合并到可执行文件当中，如果有一种动态库，几乎所有的程序都要使用到，会对磁盘空间造成很大浪费。

动态库，又名共享库，window下是DLL文件，linux下是以.so为后缀。

动态库允许使用该库的可执行文件仅包含对动态库的引用，而无需将该库拷贝到可执行文件中。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息即可。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f32f6153-5c41-4851-b95c-9c0f105cba5c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f32f6153-5c41-4851-b95c-9c0f105cba5c/Untitled.png)

linux下每个可执行文件都依赖libc.so

### 库与可执行文件的生成

静态库是在编译期间链接使用，那么动态库其实是在编译期间链接使用的。动态链接在两种情况下被链接使用，分别是

- 加载时动态链接
- 运行时动态链接

### 加载时动态链接：

阶段1: 将动态库信息写入可执行文件

编译器生成可执行文件时，需要将使用的动态库加入到链接选项中，linux下引用libMath.so, 那么需要将libMath.so加入到链接选项中，

阶段2: 加载可执行文件时依据动态库信息进行动态链接

当可执行文件加载完成后，就可以根据此信息进行动态库的查找以及符号决议了。

通过这个过程也可以清楚的看到静态库和动态库的区别，使用动态库的可执行文件中仅仅保留相应的信息，动态库的链接过程被推出到额程序启动加载时。

### 运行时动态库链接

如果我们想使用加载时动态链接，那么在编译链接生成可执行文件阶段需要告诉编译器所依赖的动态库信息，而运行时动态链接则不需要在编译链接时提供动态库信息，也就是说，在可执行文件被启动运行之前，可执行文件对依赖的动态库信息一无所知，只有当程序运行到需要调用动态库提供的代码时才会启动动态链接过程。

load-time: 程序加载完成后就开始程序执行了。

run-time:  程序开始被cpu执行，到程序执行完退出的这段时间。

由于编译链接生成可执行文件的过程中没有提供所依赖的动态库信息，因此这项任务就留给了程序员，在代码当中如果需要使用某个动态库所提供的函数，我们可以使用特定的API来运行加载动态库，在Windows下通过LoadLibrary或者LoadLibraryEx，在Linux下通过使用dlopen、dlsym、dlclose这样一组函数在运行时链接动态库。

动态链接下可执行文件的生成

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b90abcc9-2e6b-4fe1-9212-a9e98767ab96/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b90abcc9-2e6b-4fe1-9212-a9e98767ab96/Untitled.png)

dynamic段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息。

在编译链接过程中，可以同时使用动态库和静态库。那么在这两种情况下生成的可执行文件中，可执行文件中包含了静态库的数据和代码，以及动态库的必要信息。

### 动态库 vs 静态库

静态链接生成的可执行文件存在磁盘空间浪费的问题，动态库不会。

优点有：

1. 实现扩展能力

动态链接可以出现在运行时的特性，可用于扩展程序能力，如何扩展呢？实现插件时，我嗯只需要实现几个规定好的函数，我们的插件就可以运行了。

我们知道使用运行时动态链接无需在编译期间告诉链接器使用的动态库信息，可执行文件对此一无所知，只有当运行时才知道使用什么动态库，以及使用了动态库中的哪些函数，但是在编译链接可执行文件时又怎么知道插件中定义了哪些函数呢？

因此所有的插件实现函数必须都有一个统一的格式，程序在运行时需要加载所有插件，然后调用所有插件入口函数。

2.多语言编程

可以将c++代码编译链接成动态库，这样可以直接调用动态库中函数。

缺点有：

1.性能稍弱。对于加载时动态库链接，会减慢程序启动速度。

2.动态链接下的可执行文件不可以被独立运行，换句话说，如果没有提供所依赖的动态库或者所提供的动态库版本和可执行文件所依赖的不兼容，程序无法启动。

静态库的优点：链接器将所有依赖代码和数据都写入到了最终的可执行文件当中，这就消除了动态链接下的库依赖问题，没有了库的依赖问题jiu yi wei

### 重定位

CPU不断从内存中取出指令然后执行的过程。

如何确定程序运行时的内存地址呢？

可执行文件中代码以及数据的运行时内存地址是链接器指定的，也就是上面示例中add内存地址0x4004fd, 确定程序运行时地址的过程就是重定位。

为什么这个过程叫做重定位？

之所以叫做重定位是因为确定可执行文件中代码和数据的运行时地址是分为两个阶段，在第一个阶段中无法确定这些地址，只有在第二个阶段才可以确定，因此就叫做重定位。

合并同类型段以及引用符号的重定位

### 编译器的工作

编译器在将源文件编译生成目标文件时可以确定两件事：

- 定义在该源文件中函数的内存地址
- 定义在该源文件中全局变量的内存地址

这里的内存地址是相对地址，相对于自己的，为什么是相对地址，因为在生成一个目标文件时编译器并不知道这个目标文件要和哪些目标文件进行链接生成最后的可执行文件，而链接其是知道要链接哪些目标文件的，因此编译器仅仅生成一个相对地址。

对于引用类的变量，确认他们的内存地址是链接器的任务，链接器在进行链接时能确定这类变量的内存地址。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec520b9b-45ae-4826-9832-903837e2d0ae/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec520b9b-45ae-4826-9832-903837e2d0ae/Untitled.png)

这个记录就放在了目标文件的.rel.text段中。相应的如果是对外部定义的全局变量的使用，则该记录放在了目标文件的.rel.data段中。即链接器需要在链接过程中根据.rel.data以及.rel.text来填好编译器留下的空白位置，因此在这里我们进一步丰富目标文件中的内容。

生成目标文件后，编译器完成任务，编译器确定了定义在该源文件中函数以及全局变量的相对地址。对于编译器不能确定的引用类变量，编译器在目标文件的.rel.text以及.rel.data段中生成相应的记录告诉链接器要修正这些变量的地址。

### 链接器的工作

我们在静态库下可执行文件的生成一节中知道，链接器会将所有的目标文件进行合并，所有的目标文件的数据段合并到可执行文件的数据段，当合并完成后，各个文件中的相对地址也就确定了。

相对地址 + offset(偏移) = 最终内存地址

数据段和代码段中的相对地址都被链接器修正为最终的内存位置，重定位第一阶段完成，接下来是第二阶段，引用符号的重定位。

相对地址是编译器在编译过程中确定，在链接器完成后被链接器修正为最终地址，而对于编译器没有确定的所引用的外部函数以及变量的地址，编译器将其记录在了.rel.text和rel.data中，因此链接器依次扫描所有的.rel.text和rel.data并找到相应变量的最终地址，并将机器指令的0x0000修正为引用变量的最终地址。

动态库下的机器指令都是PIC代码，即位置无关代码。

## 问题：为什么链接器能确定运行时地址

我们知道只有把可执行文件加载到内存当中程序才可以开始运行。

不同的程序会被加载到内存的不同位置。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e1fefbc-6655-4865-97f4-0a6ebd0eb04b/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e1fefbc-6655-4865-97f4-0a6ebd0eb04b/Untitled.png)

### 彻底理解链接器：大项目是如何被构建出来的

MAKE:

target: 先决条件

recipe

make: 当运行make命令时，make程序会自动找到当前路径下的makefile，然后开始执行里面的规则。

### 构建大型项目

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be89efa3-e9dd-4785-9eec-b163edbc47dc/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be89efa3-e9dd-4785-9eec-b163edbc47dc/Untitled.png)